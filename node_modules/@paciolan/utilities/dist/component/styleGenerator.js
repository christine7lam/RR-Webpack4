"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _templateObject = _taggedTemplateLiteral(["\n    ", " ", ";\n  "], ["\n    ", " ", ";\n  "]);

var _styledComponents = require("styled-components");

var _styledComponents2 = _interopRequireDefault(_styledComponents);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var getContextStyling = function getContextStyling(props, _ref) {
  var base = _ref.base,
      style = _objectWithoutProperties(_ref, ["base"]);

  var contextStyle = "";
  var context = props.theme.context;

  if (context in style) {
    var contextStyleObject = style[context];

    if (typeof contextStyleObject.base === "function") {
      contextStyle += contextStyleObject.base(props);
    }

    // Apply the variation
    var variation = props.variation;
    if (typeof contextStyleObject[variation] === "function") {
      contextStyle += contextStyleObject[variation](props);
    }
  }

  return contextStyle;
};

/**
 * Validates the style object
 * Should have:
 * - A base style
 * - Every context defined outside of base should have:
 *    - a variation with a base style
 * All styles should be functions that take in a value function and return a string
 * These can access the props which is passed in as the first argument to the function
 */
var validateObject = function validateObject(_ref2) {
  var base = _ref2.base,
      style = _objectWithoutProperties(_ref2, ["base"]);

  if (typeof base !== "function") {
    console.warn("style.base in " + style + " is not a function");
  }

  for (var context in style) {
    if (!(style[context] && style[context].base !== undefined)) {
      console.warn("context " + context + " in " + style + " does not have a base");
    }

    // Check variation
    for (var variation in style[context]) {
      if (typeof style[context][variation] !== "function") {
        console.warn("variation " + variation + " in context " + context + " in " + style + " is not a function");
      }
    }
  }
};

var styleGenerator = function styleGenerator(style) {
  validateObject(style);

  return function (Component) {
    return (0, _styledComponents2.default)(Component)(_templateObject, function (props) {
      return typeof style.base === "function" ? style.base(props) : "";
    }, function (props) {
      return getContextStyling(props, style);
    });
  };
};

exports.default = styleGenerator;